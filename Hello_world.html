<!DOCTYPE html>
<html>
  <body>
    <script>
      /*One of the common ways of representing color is the RGB color model, in which the Red, Green, and Blue primary colors of light are added together in various ways to reproduce a broad array of colors.

One of the ways to determine brightness of a color is to find the value V of the alternative HSV (Hue, Saturation, Value) color model. Value is defined as the largest component of a color:

V = max(R,G,B)
You are given a list of colors in 6-digit hexidecimal notation #RRGGBB. Return the brightest of these colors!

For example,

brightest(["#001000", "#000000"]) == "#001000"
brightest(["#ABCDEF", "#123456"]) == "#ABCDEF"
If there are multiple brightest colors, return the first one:

brightest(["#00FF00", "#FFFF00", "#01130F"]) == "#00FF00"
Note that both input and output should use upper case for characters A, B, C, D, E, F.*/
      /*function brightest(colors) {
        let brightest_color = null;
        let brightest_value = -1;
        for (let i = 0; i < colors.length; i++) {
          let color = colors[i];
          let r = parseInt(color.slice(1, 3), 16);
          let g = parseInt(color.slice(3, 5), 16);
          let b = parseInt(color.slice(5, 7), 16);
          let brightness = Math.max(r, g, b);
          if (brightness > brightest_value) {
            brightest_color = color;
            brightest_value = brightness;
          }
        }
        return brightest_color;
      }*/ /*Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case). The next words should be always capitalized.

Examples
"the-stealth-warrior" gets converted to "theStealthWarrior"

"The_Stealth_Warrior" gets converted to "TheStealthWarrior"

"The_Stealth-Warrior" gets converted to "TheStealthWarrior"*/
      /*function toCamelCase(str) {
        // Проверяем исходную строку на пустоту
        if (str.length === 0) {
          return "";
        }

        // Определяем разделитель (для этого проверяем первый символ)
        let delimiter = str[0].match(/[a-z]/) ? /[-]/g : /[_-]/g;

        // Разделяем строку на слова
        let words = str.split(delimiter);

        // Обрабатываем каждое слово
        let result = words[0];
        for (let i = 1; i < words.length; i++) {
          // Сделать первую букву заглавной
          let capitalized =
            words[i].charAt(0).toUpperCase() + words[i].slice(1);
          // Добавить слово к результату
          result += capitalized;
        }

        return result;
      }*/
      /*DESCRIPTION:
Trolls are attacking your comment section!

A common way to deal with this situation is to remove all of the vowels from the trolls' comments, neutralizing the threat.

Your task is to write a function that takes a string and return a new string with all vowels removed.

For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".

Note: for this kata isn't considered a vowel.y*/ /*
      function disemvowel(str) {
        return str.replace(/[aeiouAEIOU]/g, "");
      }*/ /*An isogram is a word that has no repeating letters, consecutive or non-consecutive. 
      Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.

Example: (Input --> Output)

"Dermatoglyphics" --> true "aba" --> false "moOse" --> false (ignore letter case)

isIsogram "Dermatoglyphics" = true
isIsogram "moose" = false
isIsogram "aba" = false */

      /* function isIsogram(str) {
        const letters = str.toLowerCase().split("");
        const uniqueLetters = new Set(letters);
        return letters.length === uniqueLetters.size;
      }*/
      /*Given a string made of digits [0-9], return a string where each digit is repeated a number of times equals to its value.

Examples
explode("312")
should return :

"333122"*/
      /*function explode(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
          const num = Number(str[i]);
          if (!isNaN(num) && num >= 0 && num <= 9) {
            result += str[i].repeat(num);
          }
        }
        return result;
      }*/
      /*function explode(s) {
        s = s.split("");
        newS = "";
        for (let i = 0; i < s.length; i++) {
          switch (s[i]) {
            case "1":
              newS = newS + "1";
              break;
            case "2":
              newS = newS + "22";
              break;
            case "3":
              newS = newS + "333";
              break;
            case "4":
              newS = newS + "4444";
              break;
            case "5":
              newS = newS + "55555";
              break;
            case "6":
              newS = newS + "666666";
              break;
            case "7":
              newS = newS + "7777777";
              break;
            case "8":
              newS = newS + "88888888";
              break;
            case "9":
              newS = newS + "999999999";
              break;
            case "0":
              newS = newS + "";
              break;
          }
        }
        return newS;
      }*/
      /*Johnny is a farmer and he annually holds a beet farmers convention "Drop the beet".

Every year he takes photos of farmers handshaking. Johnny knows that no two farmers handshake more than once. He also knows that some of the possible handshake combinations may not happen.

However, Johnny would like to know the minimal amount of people that participated this year just by counting all the handshakes.

Help Johnny by writing a function, that takes the amount of handshakes and returns the minimal amount of people needed to perform these handshakes (a pair of farmers handshake only once).*/
      /* function getParticipants(handshakes) {
        let people = 0;
        let sum = 0;

        while (sum < handshakes) {
          people++;
          sum += people - 1;
        }

        return people;
      }*/ $; /*The goal of this exercise is to convert a string to a new string where each character in the new string is if that character appears only once in the original string, or if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate."("")"

Examples
"din"      =>  "((("
"recede"   =>  "()()()"
"Success"  =>  ")())())"
"(( @"     =>  "))((" */
      /* function duplicateEncode(word) {
        // Convert all characters to lowercase
        word = word.toLowerCase();

        // Create an empty object to store character counts
        const charCounts = {};

        // Iterate over each character in the string and count its occurrences
        for (let i = 0; i < word.length; i++) {
          const char = word.charAt(i);
          charCounts[char] = (charCounts[char] || 0) + 1;
        }

        // Iterate over each character in the string and replace it with
        // a '(' or ')' based on its occurrence count in the charCounts object
        let result = "";
        for (let i = 0; i < word.length; i++) {
          const char = word.charAt(i);
          result += charCounts[char] === 1 ? "(" : ")";
        }

        return result;
      }*/
      /*DESCRIPTION:
I love Fibonacci numbers in general, but I must admit I love some more than others.

I would like for you to write me a function that, when given a number n (n >= 1 ), returns the nth number in the Fibonacci Sequence.

For example:

   nthFibo(4) == 2
Because 2 is the 4th number in the Fibonacci Sequence.

For reference, the first two numbers in the Fibonacci sequence are 0 and 1, and each subsequent number is the sum of the previous two.*/
      /*function nthFibo(n) {
        let [prev, curr] = [0, 1];
        for (let i = 1; i < n; i++) [prev, curr] = [curr, prev + curr];
        return prev;
      }*/
      /*Your task in order to complete this Kata is to write a function which formats a duration, given as a number of seconds, in a human-friendly way.
The function must accept a non-negative integer. If it is zero, it just returns . Otherwise, the duration is expressed as a combination of , , , and ."now"yearsdayshoursminutesseconds
It is much easier to understand with an example:
* For seconds = 62, your function should return 
    "1 minute and 2 seconds"
* For seconds = 3662, your function should return
    "1 hour, 1 minute and 2 seconds"
For the purpose of this Kata, a year is 365 days and a day is 24 hours.
Note that spaces are important.
Detailed rules
The resulting expression is made of components like , , etc. In general, a positive integer and one of the valid units of time, separated by a space. The unit of time is used in plural if the integer is greater than 1.4 seconds1 year
The components are separated by a comma and a space (). Except the last component, which is separated by , just like it would be written in English. ", "" and "
A more significant units of time will occur before than a least significant one. Therefore, is not correct, but is.1 second and 1 year1 year and 1 second
Different components have different unit of times. So there is not repeated units like in .5 seconds and 1 second
A component will not appear at all if its value happens to be zero. Hence, is not valid, but it should be just .1 minute and 0 seconds1 minute
A unit of time must be used "as much as possible". It means that the function should not return , but instead. Formally, the duration specified by of a component must not be greater than any valid more significant unit of time.61 seconds1 minute and 1 sec*/
      /*  function formatDuration(seconds) {
        if (seconds === 0) {
          return "now";
        }
        const timeUnits = {
          year: 365 * 24 * 60 * 60,
          day: 24 * 60 * 60,
          hour: 60 * 60,
          minute: 60,
          second: 1,
        };
        const timeStrings = [];
        for (const [unit, secondsPerUnit] of Object.entries(timeUnits)) {
          const count = Math.floor(seconds / secondsPerUnit);
          if (count > 0) {
            const unitString = count > 1 ? `${unit}s` : unit;
            timeStrings.push(`${count} ${unitString}`);
            seconds %= secondsPerUnit;
          }
        }
        const lastString = timeStrings.pop();
        if (timeStrings.length === 0) {
          return lastString;
        } else {
          return `${timeStrings.join(", ")} and ${lastString}`;
        }
      }*/
      /*Haskell has some useful functions for dealing with lists:

$ ghci
GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
λ head [1,2,3,4,5]
1
λ tail [1,2,3,4,5]
[2,3,4,5]
λ init [1,2,3,4,5]
[1,2,3,4]
λ last [1,2,3,4,5]
5
Your job is to implement these functions in your given language. Make sure it doesn't edit the array; that would cause problems! Here's a cheat sheet:

| HEAD | <----------- TAIL ------------> |
[  1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
| <----------- INIT ------------> | LAST |

head [x] = x
tail [x] = []
init [x] = []
last [x] = x
Here's how I expect the functions to be called in your language:

head([1,2,3,4,5]); => 1
tail([1,2,3,4,5]); => [2,3,4,5]*/
      /*Pair of gloves
Winter is coming, you must prepare your ski holidays. The objective of this kata is to determine the number of pair of gloves you can constitute from the gloves you have in your drawer.

Given an array describing the color of each glove, return the number of pairs you can constitute, assuming that only gloves of the same color can form pairs.

Examples:
input = ["red", "green", "red", "blue", "blue"]
result = 2 (1 red pair + 1 blue pair)

input = ["red", "red", "red", "red", "red", "red"]
result = 3 (3 red pairs)*/
      /* function numberOfPairs(gloves) {
        const pairs = {};
        let count = 0;
        for (let i = 0; i < gloves.length; i++) {
          const glove = gloves[i];
          pairs[glove] = (pairs[glove] || 0) + 1;
          if (pairs[glove] % 2 === 0) {
            count++;
          }
        }
        return count;
      }*/ /*In this kata you're expected to sort an array of 32-bit integers in ascending order of the number of on bits they have.

E.g Given the array [7, 6, 15, 8]

7 has 3 on bits (000...0111)
6 has 2 on bits (000...0011)
15 has 4 on bits (000...1111)
8 has 1 on bit (000...1000)
So the array in sorted order would be [8, 6, 7, 15].

In cases where two numbers have the same number of bits, compare their real values instead.

E.g between 10 (...1010) and 12 (...1100), they both have the same number of on bits '2' but the integer 10 is less than 12 so it comes first in sorted order.

Your task is to write the function sortBybit() that takes an array of integers and sort them as described above.

Note: your solution has to sort the array in place.

Example:

[3, 8, 3, 6, 5, 7, 9, 1]   =>    [1, 8, 3, 3, 5, 6, 9, 7]*/
      /*  function sortByBit(arr) {
        arr.sort((a, b) => {
          const bitCountA = countBits(a);
          const bitCountB = countBits(b);
          if (bitCountA === bitCountB) {
            return a - b;
          } else {
            return bitCountA - bitCountB;
          }
        });
      }

      function countBits(num) {
        let count = 0;
        while (num > 0) {
          count += num & 1;
          num >>= 1;
        }
        return count;
      }*/ /*You will be given a list of objects. Each object has type, material, and possibly secondMaterial. The existing materials are: paper, glass, organic, and plastic.

Your job is to sort these objects across the 4 recycling bins according to their material (and secondMaterial if it's present), by listing the type's of objects that should go into those bins.

Notes
The bins should come in the same order as the materials listed above
All bins should be listed in the output, even if some of them are empty
If an object is made of two materials, its type should be listed in both of the respective bins
The order of the type's in each bin should be the same as the order of their respective objects was in the input list
Example
input = [
  {"type": "rotten apples", "material": "organic"},
  {"type": "out of date yogurt", "material": "organic", "secondMaterial": "plastic"},
  {"type": "wine bottle", "material": "glass", "secondMaterial": "paper"},
  {"type": "amazon box", "material": "paper"},
  {"type": "beer bottle", "material": "glass", "secondMaterial": "paper"}
]

output = [
  ["wine bottle", "amazon box", "beer bottle"],
  ["wine bottle", "beer bottle"],
  ["rotten apples", "out of date yogurt"],
  ["out of date yogurt"]
]*/ /*
      function recycle(arr) {
        const bins = [[], [], [], []];
        for (let obj of arr) {
          if (obj.material === "paper") {
            bins[0].push(obj.type);
          } else if (obj.material === "glass") {
            bins[1].push(obj.type);
          } else if (obj.material === "organic") {
            bins[2].push(obj.type);
          } else if (obj.material === "plastic") {
            bins[3].push(obj.type);
          }
          if (obj.secondMaterial) {
            if (obj.secondMaterial === "paper") {
              bins[0].push(obj.type);
            } else if (obj.secondMaterial === "glass") {
              bins[1].push(obj.type);
            } else if (obj.secondMaterial === "organic") {
              bins[2].push(obj.type);
            } else if (obj.secondMaterial === "plastic") {
              bins[3].push(obj.type);
            }
          }
        }
        return bins;
      }*/ /*You are writing a function that takes two sets of arguments of arbitrary length. The return value will be the sum of the values of all of the arguments.

The function should contain at least 1 argument per set.

calculate(1)(1) // should return 2
calculate(1,1)(1) // should return 3
calculate(1,1)(1,-1) // should return 2
calculate(2,4)(3,7,1) // should return 17*/
      /*function calculate(...args1) {
  return function(...args2) {
    const totalArgs = [...args1, ...args2];
    return totalArgs.reduce((acc, curr) => acc + curr, 0);
  }
}*/ /*DESCRIPTION:
Implement the method find which takes in an two parameters object and path. The path will be a period-delimited string of properties that we will use to traverse through our object to find our target value.

Check out this Codecast to get started! https://codecast.qualified.io/interaction/594197b92f524d001c1ab790

Edge Cases And Further Consideration
Be sure to handle passing array indices. For example, if we have an object: { people: ['John', 'Dave', 'Lisa'] } and the path is 'people.1', the target value is 'Dave' which is the string at position 1 inside of the people array.

Also this method should handle invalid paths. If we have an object { user: { name: 'Dan' } } and the path is 'user.wallet.money', we should return undefined. Valid paths are exclusive to properties on the object which are not inherited, in other words it is specific to this object and does not need to look up the prototype chain.*/
      /* function find(obj, path) {
        // Split the path into an array of property names
        const properties = path.split(".");

        // Initialize the current value as the input object
        let currentValue = obj;

        // Loop through each property in the array of property names
        for (let i = 0; i < properties.length; i++) {
          const property = properties[i];

          // If the current value is an array and the property is a valid integer index
          if (Array.isArray(currentValue) && /^\d+$/.test(property)) {
            const index = parseInt(property);
            if (index >= 0 && index < currentValue.length) {
              currentValue = currentValue[index];
            } else {
              return undefined; // Invalid index, return undefined
            }
          } else if (
            typeof currentValue === "object" &&
            currentValue.hasOwnProperty(property)
          ) {
            // If the current value is an object and has the property, update the current value
            currentValue = currentValue[property];
          } else {
            return undefined; // Invalid property, return undefined
          }
        }

        return currentValue; // Return the final value
      }*/ /*DESCRIPTION:
Run-length encoding (RLE) is a very simple form of data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run. Wikipedia

Task
Your task is to write such a run-length encoding. For a given string, return a list (or array) of pairs (or arrays) [ (i1, s1), (i2, s2), …, (in, sn) ], such that one can reconstruct the original string by replicating the character sx ix times and concatening all those strings. Your run-length encoding should be minimal, ie. for all i the values si and si+1 should differ.

Examples
As the article states, RLE is a very simple form of data compression. It's only suitable for runs of data, as one can see in the following example:

runLengthEncoding("hello world!")
 //=>      [[1,'h'], [1,'e'], [2,'l'], [1,'o'], [1,' '], [1,'w'], [1,'o'], [1,'r'], [1,'l'], [1,'d'], [1,'!']]
It's very effective if the same data value occurs in many consecutive data elements:

runLengthEncoding("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb")
 // => [[34,'a'], [3,'b']]*/
      /* function runLengthEncoding(str) {
        let result = [];
        let count = 1;
        for (let i = 0; i < str.length; i++) {
          if (str[i] === str[i + 1]) {
            count++;
          } else {
            result.push([count, str[i]]);
            count = 1;
          }
        }
        return result;
      }*/ /*You are given a dictionary/hash/object containing some languages and your test results in the given languages. Return the list of languages where your test score is at least 60, in descending order of the scores.

Note: the scores will always be unique (so no duplicate values)

Examples
{"Java": 10, "Ruby": 80, "Python": 65}    -->  ["Ruby", "Python"]
{"Hindi": 60, "Dutch" : 93, "Greek": 71}  -->  ["Dutch", "Greek", "Hindi"]
{"C++": 50, "ASM": 10, "Haskell": 20}     -->  []*/
      /*Friday 13th or Black Friday is considered as unlucky day. Calculate how many unlucky days are in the given year.

Find the number of Friday 13th in the given year.

Input: Year in Gregorian calendar as integer.

Output: Number of Black Fridays in the year as an integer.

Examples:

unluckyDays(2015) == 3
unluckyDays(1986) == 1*/
      /*function unluckyDays(year) {
        let count = 0;
        for (let month = 0; month < 12; month++) {
          const date = new Date(year, month, 13);
          if (date.getDay() === 5) {
            // 5 is Friday
            count++;
          }
        }
        return count;
      }*/ /*There's no such thing as private properties on a coffeescript object! But, maybe there are?

Implement a function createSecretHolder(secret) which accepts any value as secret and returns an object with ONLY two methods

getSecret() which returns the secret
setSecret() which sets the secret
obj = createSecretHolder(5)
obj.getSecret() # returns 5
obj.setSecret(2)
obj.getSecret() # returns 2*/
      /* function createSecretHolder(secret) {
        return {
          getSecret: function () {
            return secret;
          },
          setSecret: function (newSecret) {
            secret = newSecret;
          },
        };
      }*/ /*We want to create a function, which returns an array of functions, which return their index in the array. For better understanding, here an example:

var callbacks = createFunctions(5); // create an array, containing 5 functions

callbacks[0](); // must return 0
callbacks[3](); // must return 3
We already implemented that function, but when we actually run the code, the result doesn't look like what we expected. Can you spot, what's wrong with it? A test fixture is also available*/
      function createFunctions(n) {
        var callbacks = [];

        for (let i = 0; i < n; i++) {
          callbacks.push(function () {
            return i;
          });
        }

        return callbacks;
      }
    </script>
  </body>
</html>
