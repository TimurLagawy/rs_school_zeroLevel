<!DOCTYPE html>
<html>
  <body>
    <script>
      /*One of the common ways of representing color is the RGB color model, in which the Red, Green, and Blue primary colors of light are added together in various ways to reproduce a broad array of colors.

One of the ways to determine brightness of a color is to find the value V of the alternative HSV (Hue, Saturation, Value) color model. Value is defined as the largest component of a color:

V = max(R,G,B)
You are given a list of colors in 6-digit hexidecimal notation #RRGGBB. Return the brightest of these colors!

For example,

brightest(["#001000", "#000000"]) == "#001000"
brightest(["#ABCDEF", "#123456"]) == "#ABCDEF"
If there are multiple brightest colors, return the first one:

brightest(["#00FF00", "#FFFF00", "#01130F"]) == "#00FF00"
Note that both input and output should use upper case for characters A, B, C, D, E, F.*/
      /*function brightest(colors) {
        let brightest_color = null;
        let brightest_value = -1;
        for (let i = 0; i < colors.length; i++) {
          let color = colors[i];
          let r = parseInt(color.slice(1, 3), 16);
          let g = parseInt(color.slice(3, 5), 16);
          let b = parseInt(color.slice(5, 7), 16);
          let brightness = Math.max(r, g, b);
          if (brightness > brightest_value) {
            brightest_color = color;
            brightest_value = brightness;
          }
        }
        return brightest_color;
      }*/ /*Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case). The next words should be always capitalized.

Examples
"the-stealth-warrior" gets converted to "theStealthWarrior"

"The_Stealth_Warrior" gets converted to "TheStealthWarrior"

"The_Stealth-Warrior" gets converted to "TheStealthWarrior"*/
      /*function toCamelCase(str) {
        // Проверяем исходную строку на пустоту
        if (str.length === 0) {
          return "";
        }

        // Определяем разделитель (для этого проверяем первый символ)
        let delimiter = str[0].match(/[a-z]/) ? /[-]/g : /[_-]/g;

        // Разделяем строку на слова
        let words = str.split(delimiter);

        // Обрабатываем каждое слово
        let result = words[0];
        for (let i = 1; i < words.length; i++) {
          // Сделать первую букву заглавной
          let capitalized =
            words[i].charAt(0).toUpperCase() + words[i].slice(1);
          // Добавить слово к результату
          result += capitalized;
        }

        return result;
      }*/
      /*DESCRIPTION:
Trolls are attacking your comment section!

A common way to deal with this situation is to remove all of the vowels from the trolls' comments, neutralizing the threat.

Your task is to write a function that takes a string and return a new string with all vowels removed.

For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".

Note: for this kata isn't considered a vowel.y*/ /*
      function disemvowel(str) {
        return str.replace(/[aeiouAEIOU]/g, "");
      }*/ /*An isogram is a word that has no repeating letters, consecutive or non-consecutive. 
      Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.

Example: (Input --> Output)

"Dermatoglyphics" --> true "aba" --> false "moOse" --> false (ignore letter case)

isIsogram "Dermatoglyphics" = true
isIsogram "moose" = false
isIsogram "aba" = false */

      /* function isIsogram(str) {
        const letters = str.toLowerCase().split("");
        const uniqueLetters = new Set(letters);
        return letters.length === uniqueLetters.size;
      }*/
      /*Given a string made of digits [0-9], return a string where each digit is repeated a number of times equals to its value.

Examples
explode("312")
should return :

"333122"*/
      /*function explode(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
          const num = Number(str[i]);
          if (!isNaN(num) && num >= 0 && num <= 9) {
            result += str[i].repeat(num);
          }
        }
        return result;
      }*/
      /*function explode(s) {
        s = s.split("");
        newS = "";
        for (let i = 0; i < s.length; i++) {
          switch (s[i]) {
            case "1":
              newS = newS + "1";
              break;
            case "2":
              newS = newS + "22";
              break;
            case "3":
              newS = newS + "333";
              break;
            case "4":
              newS = newS + "4444";
              break;
            case "5":
              newS = newS + "55555";
              break;
            case "6":
              newS = newS + "666666";
              break;
            case "7":
              newS = newS + "7777777";
              break;
            case "8":
              newS = newS + "88888888";
              break;
            case "9":
              newS = newS + "999999999";
              break;
            case "0":
              newS = newS + "";
              break;
          }
        }
        return newS;
      }*/
      /*Johnny is a farmer and he annually holds a beet farmers convention "Drop the beet".

Every year he takes photos of farmers handshaking. Johnny knows that no two farmers handshake more than once. He also knows that some of the possible handshake combinations may not happen.

However, Johnny would like to know the minimal amount of people that participated this year just by counting all the handshakes.

Help Johnny by writing a function, that takes the amount of handshakes and returns the minimal amount of people needed to perform these handshakes (a pair of farmers handshake only once).*/
      /* function getParticipants(handshakes) {
        let people = 0;
        let sum = 0;

        while (sum < handshakes) {
          people++;
          sum += people - 1;
        }

        return people;
      }*/ $; /*The goal of this exercise is to convert a string to a new string where each character in the new string is if that character appears only once in the original string, or if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate."("")"

Examples
"din"      =>  "((("
"recede"   =>  "()()()"
"Success"  =>  ")())())"
"(( @"     =>  "))((" */
      function duplicateEncode(word) {
        // Convert all characters to lowercase
        word = word.toLowerCase();

        // Create an empty object to store character counts
        const charCounts = {};

        // Iterate over each character in the string and count its occurrences
        for (let i = 0; i < word.length; i++) {
          const char = word.charAt(i);
          charCounts[char] = (charCounts[char] || 0) + 1;
        }

        // Iterate over each character in the string and replace it with
        // a '(' or ')' based on its occurrence count in the charCounts object
        let result = "";
        for (let i = 0; i < word.length; i++) {
          const char = word.charAt(i);
          result += charCounts[char] === 1 ? "(" : ")";
        }

        return result;
      }
    </script>
  </body>
</html>
